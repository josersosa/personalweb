[
  {
    "path": "posts/2021-04-29-sincronizacin-de-directorios-con-rsync/",
    "title": "Sincronización de directorios con rsync",
    "description": "Si bien, herramientas de control de versiones y el uso de la nube ayudan a centralizar nuestra información, la sincronizacion de archivos entre diferentes equipos y ambientes de trabajo puede convertirse en un problema, para eso podemos usar rcync.",
    "author": [
      {
        "name": "José R Sosa",
        "url": "https://example.com/josersosa"
      }
    ],
    "date": "2021-04-29",
    "categories": [
      "Linux Recipes"
    ],
    "contents": "\n\nContents\nComo se usa rcync\nSincronización completa\nTransferencia comprimida\nSincronización remota con SSH\nExcepciones en la sincronización\nComo se decide que archivo debe ser actualizado?\nEjemplos\nTODOs\n\nDesde que vengo trabajando remoto utilizo indistintamente diferentes equipos, el personal y el de la oficina. Esto ha provocado que la sincronización de mis archivos se haya convertido en un verdadero problema, lo que he resuelto con rcync.\nComo se usa rcync\nPara actualizar los contenidos de una carpeta basados en los contenidos de otra utilizamos:\n\nrsync -rtvu carpeta_origen/ carpeta_destino/ \n\nUna vista de los parámetos de rcync:\n\n-v, –verbose    : verbose output\n-q, –quiet      : suppress message output\n-a, –archive    : archive files and directory while synchronizing ( -a equal to following options -rlptgoD)\n-r, –recursive  : sync files and directories recursively\n-c, --checksum  : skip based on checksum, not mod-time & size\n-b, –backup     : take the backup during synchronization\n-u, –update     : don’t copy the files from source to destination if destination files are newer\n-l, –links      : copy symlinks as symlinks during the sync\n-n, –dry-run    : perform a trial run without synchronization\n-e, –rsh=COMMAND: mention the remote shell to use in rsync. By example use '-e ssh'\n-z, –compress   : compress file data during the transfer\n-h, –human-readable: display the output numbers in a human-readable format\n-P : Resume large file transfer after getting failed in scp\n-f : for include o exclude files o directories, example -f\"+ */\" -f\"- *\" for sync the directory structure without copying files\n--include   : to specify those files or directories which you want to include in your sync \n--exclude   : exclude files and folders with you don’t want to be transferred.\n--delete    : if a file or directory not exist at the source, but already exists at the destination, delete that existing file/directory at the target\n--max-size= : put limit on file transfer size. To specify the size in KB use K, MB use M and for GB use G (ej: --max-size='500K')\n--bwlimit=  : put restriction on data transfer speed in KB/s (ej: --bwlimit=600)\n–progress       : show the sync progress during transfer by file\n-e : To specify a protocol with rsync, by example using “ssh”\n\nSincronización completa\nEn el caso de que necesitemos remover los archivos que fueron borrados de la carpeta origen en la carpeta destino, es decir cuando queremos que las dos carpetas (origen y destino) sean idénticas, debemos utilizar el parámetro - -delete, esto usado en conjunto con el parámetro previo -u que actualiza los archivos modificados nos permite mantener dos carpetas en sincronía ahorrando ancho de banda.\n\nrsync -rtvu --delete carpeta_origen/ carpeta_destino/\n\nTransferencia comprimida\nPara ahorrar algo de ancho de banda, y usualmente también ahorrar algo de tiempo, podemos comprimir la información que está será transferida, para esto agregamos el parámetro -z a rsync:\n\nrsync -rvz carpeta_origen/ carpeta_destino/ \n\nSincronización remota con SSH\nPara actualizar los archivos de una carpeta local a una carpeta remota, utilizando un dominio, una dirección de IP o un servidor definido en el archivo de configuración de SSH:\n\nrsync -rtvz carpeta_origen/ usuario@dominio:/ruta/a/carpeta_destino/\n\nAhora para actualizar archivos de una carpeta remota a carpeta local, utilizando un dominio, una dirección de IP o un servidor definido en el archivo de configuración de SSH:\n\nrsync -rtvz usuario@dominio:/ruta/a/carpeta_origen/ carpeta_destino/\n\nExcepciones en la sincronización\nEl parámetro - -exclude seguido del directorio o el archivo que queremos excluir nos permite definir directorios/archivo que no serán sincronizados. La carpeta de origen o la carpeta de destino pueden ser un directorio local o un directorio remoto como se explico en la sección previa.\n\nrsync -rtv --exclude 'directorio' carpeta_origen/ carpeta_destino/\nrsync -rtv --exclude 'archivo.txt' carpeta_origen/ carpeta_destino/\nrsync -rtv --exclude 'direccion/a/directorio' carpeta_origen/ carpeta_destino/\nrsync -rtv --exclude 'direccion/a/archivo.txt' carpeta_origen/ carpeta_destino/ \n\nTambién podemos colocar la lista de directorios o archivos que deseamos excluir en una archivo de texto (por ejemplo excluidos.txt) y usar la opción –exclude-from de la siguiente forma:\n\nrsync -rvz --exclude-from 'excluidos.txt' carpeta_origen/ carpeta_destino/\n\nComo se decide que archivo debe ser actualizado?\nPor defecto, rsync toma la fecha de la última modificación del archivo y el tamaño de este para decidir que archivos necesitan ser transferidos y que archivos pueden ser ignorados, pero podemos utilizar en lugar de este método un hash para decidir si el archivo es diferente o no. Para hacer esto necesitamos usar el parámetro -c, que realizará un checksum en los archivos a ser transferidos. Esto ignorará cualquier archivo donde el checksum coincide.\nEjemplos\nAquí tengo algunos ejemplos de como realizo la sincronización de archivos a varios de los equipos que uso con frecuentemente:\n\nrsync -rvuc /media/716D-15A9/Sincronizar/ /media/LOCAL/Personal/Sincronizar/\nrsync -rvuc /media/716D-15A9/Sincronizar/ /media/LOCAL/archivo/\nrsync -rvuc /media/716D-15A9/Sincronizar/ /media/TI10657300E/Temp/josersosa/\nrsync -rvuc /media/716D-15A9/Sincronizar/ /media/6AE0F943E0F91653/Temp/Jose/\n\nTODOs\nAhora queda pendiente automatizar este proceso, de forma que cuando se introduzca cierto pendrive en un equipo se ejecute un script que consulte al usuario si desea que este sea sincronizado en ese computador. Esta acción podría realizarse tanto al momento de insertar el pen como al momento de solicitar su extracción.\nFuente de este post\nhttp://www.jveweb.net/archivo/2010/11/sincronizando-carpetas-con-rsync.html\nhttps://www.linuxtechi.com/rsync-command-examples-linux/\nhttps://www.computerhope.com/unix/rsync.htm\nhttps://www.geeksforgeeks.org/rsync-command-in-linux-with-examples/\n\n\n\n",
    "preview": "posts/2021-04-29-sincronizacin-de-directorios-con-rsync/../../images/edex-ui.png",
    "last_modified": "2021-04-29T06:54:33+00:00",
    "input_file": {},
    "preview_width": 800,
    "preview_height": 450
  },
  {
    "path": "posts/2021-04-28-datasets-para-proyectos-de-machine-learning/",
    "title": "Datasets para proyectos de Machine Learning",
    "description": "Si estas buscado un conjunto de datos \"especial\" para tu proyecto de Machine Learning, he preparado una lista, que si bien no es exhaustiva, si que sirve como propuesta de por donde comenzar a buscar.",
    "author": [
      {
        "name": "José R Sosa",
        "url": "https://example.com/josersosa"
      }
    ],
    "date": "2021-04-28",
    "categories": [
      "Data Science"
    ],
    "contents": "\n\nContents\nFuentes de datos\nBucadores de datasets\nRecopilaciones o temáticos\nCompetencia o retos de ciencia de datos\nRepositorios universitarios\nPortales de datos abiertos\nProveedores de computo en la nube\nAPIs de datos\n\n\nFuentes de datos\nEsta recopilación consiste en un lista de repositorios o buscadores de datasets para todo tipo de proyectos de Machine Learning e Inteligencia Artificial. Algunas de estas fuentes de datos son en realidad buscadores, otros simples listas, Algunos son genéricos y otro son temáticos:\nBucadores de datasets\nBuscador de datasets de Google: datasetsearch.research.google.com\nBuscador de datasets de paperwithcode: paperswithcode.com/datasets\nRecopilaciones o temáticos\nDatasets in Python: towardsdatascience.com\nThe R Datasets Package: stat.ethz.ch\nThe Big Bad NLP Database : datasets.quantumstat\nOpen repository of web crawl data: Common Crawl\nMultiscale Machine Learning In Coupled Earth System Modeling M²LInES\nKDnuggets Datasets\n25 Best NLP Datasets\nCompetencia o retos de ciencia de datos\nExplore, analyze, and share quality data with Kaggle datasets: kaggle.com\nA a Large-Scale Graph ML Competiton: OGB-LSC @ KDD Cup 2021\nRepositorios universitarios\nUC Irvine Machine Learning Repository: http://archive.ics.uci.edu/ml/\nStanford Large Network Dataset Collection https://snap.stanford.edu/data/\nPortales de datos abiertos\nPortal Brasileño de datos abiertos: dados.gog.br\nPortal de datos abiertos de Uruguay: http://datos.gub.uy/\nPortal de datos abiertos de Canadá: http://open.canada.ca/data/en/dataset\nPortal de datos abiertos de Estados Unidos: https://www.data.gov/\nPortal de datos abiertos de Reino Unido: https://data.gov.uk/\nComunidad Económica Europea: https://open-data.europa.eu/es/\nBanco Mundial: http://data.worldbank.org/\nProveedores de computo en la nube\nAmazon Web Services (AWS)\nGoogle Cloud Platform (GCP)\nMicrosoft (Azure)\nAPIs de datos\nAPIs de google\nAlgunas API financieras\nAPI de Flickr\nAPIs de Twitter\n\n\n\n",
    "preview": "posts/2021-04-28-datasets-para-proyectos-de-machine-learning/../../images/datasets_peq.png",
    "last_modified": "2021-04-28T04:30:08+00:00",
    "input_file": {},
    "preview_width": 681,
    "preview_height": 409
  },
  {
    "path": "posts/2020-09-07-imgenes-de-fractales-en-gran-formato-con-r/",
    "title": "Imágenes de fractales en gran formato con R",
    "description": "Aproveché unos días de mis vacaciones para preparar algunas gráficas en R, que quería hacer desde hace tiempo para adornar mi estudio. Se trata de fractales y atractores extraños, pero quería hacerlos de forma de poder imprimirlos en formato grande, como afiches.",
    "author": [
      {
        "name": "José R Sosa",
        "url": "https://example.com/josersosa"
      }
    ],
    "date": "2020-09-07",
    "categories": [
      "R",
      "Chaos and Fractals",
      "Computer Graphics",
      "Data Science"
    ],
    "contents": "\n\nContents\nGráficas en gran formato con R\nAlgoritmos de construcción\nEstructuras de datos\nProcesamiento optimización\nDimensiones y formato de la imagen\nAlising\nLayout de impresión\n\n\nLa idea es no tener que escalar las imágenes para imprimirlas en formatos grandes, sino que en vez de eso, estuvieran elaboradas pixel a pixel para estos formatos como el A1 (23.4 x 33.1 in) a 300dpi o el A2 (16.5 x 23.4 in) a 600dpi.\nHe aquí algunos resultados:\nConjunto de Mandelbrot\nAtractor de Lorenz\nAtractor de Clifford\n\n\n\nBreve reseña\nBreve reseña\nBreve reseña\nImagen de alta resolución\nImagen de alta resolución\nImagen de alta resolución\nCódigo fuente\nCódigo fuente\nCódigo fuente\nPongo a la disposición estas imágenes en alta resolución para su libre descarga, bajo licencia Creative Commons, así como los enlaces a los repositorios de código fuente para regenerarlas o modificarlas. En un próximo post estaré publicando un tutorial explicando como construir este tipo de gráficas con R, así como algunas reseñas donde expongo, desde mi punto de vista, del por qué son de tanto interés.\nGráficas en gran formato con R\nEl reto de crear imágenes de fractales o atractores extraños de gran formato implica resolver varios asuntos, entre ellos están:\nAlgoritmos de construcción.\nEstructuras de datos.\nProcesamiento y optimización.\nDimensiones y formato de la imagen.\nEl problema del Alising.\nLayout de impresión.\nAlgoritmos de construcción\nLa mayoría de los fractales o atractores extraños se construyen a partir de la definición y simulación de alguna dinámica, por ejemplo \\[\nX_{n+1}=F(X_n)\n\\] con cual, se construyen secuencias de valores para el vector X , a partir de un valor inicial o condición inicial para dicho sistema, para esto y se pueden utilizar varias estrategias:\nDiagramas de fase: consiste en la proyección de las trayectorias construidas con las variables de estado juntas en el espacio n-dimensional hacia un plano 2D.\nEscala de valores de convergencia, que consiste en recorrer una sección del espacio de posibles valores iniciales y representar en una escala de colores a los que llevan a la dinámica a converger, tomando colores según el valor de convergencia.\nTiempo de escape, consiste en en recorrer una sección del espacio de posibles condiciones iniciales y seleccionando aquellas que producen la divergencia de la dinámica, pero tomando como valor de referencia para la selección del color, la cantidad de iteraciones que requirieron para alcanzar cierto umbral, como una especie de medida de velocidad de escape.\nCualquier otro método creativo que se nos ocurra.\nEstructuras de datos\nLas estructuras de datos para construir estas gráficas son simples, el verdadero problema es contar con la memoria RAM suficiente para almacenar series de 20 millones de registros para cada una de las variables del vector de estados, o matrices en el orden de 10.000x10.000, es decir 100 millones de puntos o más\nProcesamiento optimización\nPara lograr un algoritmo capaz de construir nuestras imágenes debemos pensar en la eficiencia, en la medida de lo posible ejecutar procesos de calculo vectoriales o recurrir a sub-procesos en C/C++ con la ayuda del paquete rcpp.\nDimensiones y formato de la imagen\nCómo comentamos al comienzo, la idea principal es generar imágenes que no requieran ser escaladas o reducidas al momento de la impresión, es decir que tengan las dimensiones exactas en las cuales se verán. Recordemos que si una imagen es reducida, pierde información visual, mientras que si es agrandada, esta se pixelará. Por esta razón, primero que nada debemos decidir el tamaño impreso de nuestra gráfica.\nTabla de tamaños estándar de papel\nSize\nWidth x Height (mm)\nWidth x Height (in)\nA0\n841 x 1189 mm\n33.1 x 46.8 in\nA1\n594 x 841 mm\n23.4 x 33.1 in\nA2\n420 x 594 mm\n16.5 x 23.4 in\nA3\n297 x 420 mm\n11.7 x 16.5 in\nA4\n210 x 297 mm\n8.3 x 11.7 in\nA5\n148 x 210 mm\n5.8 x 8.3 in\nA6\n105 x 148 mm\n4.1 5.8 in\nA7\n74 x 105 mm\n2.9 x 4.1 in\nA8\n52 x 74 mm\n2.0 x 2.9 in\nA9\n37 x 52 mm\n1.5 x 2.0 in\nA10\n26 x 37 mm\n1.0 x 1.5 in\nEn R es posible graficar sobre dispositivos de despliegue distintos a la pantalla, en vez de esto podemos crear imágenes directamente en archivos con diversos formatos con funciones como png(), jpg(), tiff() o pdf(). Entre sus parámetros es posible especificar el tamaño del gráfico en diferentes unidades de medida (“cm”, “mm” o “in”), así como la resolución en “dpi” (puntos por pulgada). En relación con el formato, la recomendación es usar el PNG, dado que JPEG optimiza la imagen reduciendo su tamaño pero perdiendo calidad. Por ejemplo para generar una imagen de tamaño A2 a 600dpi y en formato PNG, el código sería de la siguiente manera:\npng(filename=\"graphic.png\", units=\"in\", width=23.4, height=16.5, res=600)\n    codigo de generación de la imagen aqui...\ndev.off()\nLe estamos indicando al dispositivo de salida que la grafica tendrá un tamaño de 23.4x16.5 pulgadas (A2) a una resolución de 600dpi. Esta misma imagen también se podría imprimir en un papel tamaño A1 pero si se reduce la resolución a 300dpi.\nAlising\nEn general, durante el proceso de generación del gráfico, cada pixel se calcula de manera exacta, sin embargo esto no es conveniente para los efectos estéticos, debido a efecto de alising, especialmente cuando lo que se despliega en la imagen son trayectorias o líneas. El Alising es el ese tipo de efecto de escalera que tienen la líneas cuando se dibujan de forma oblicua.\nPara reducir este problema se utiliza una técnica llamada anti-alising que consisten en dibujar los pixeles con cierto grado de transparencia dependiendo que tan cercanos están de la línea imaginaria central que podemos trazar en cualquier línea gráfica, haciendo que el trazo parezca suave en lugar de escalonado. Para esto se requiere acceder a las primitivas de despliegue gráfico del sistema operativo. No todos los sistemas soportan este tipo de primitivas, uno de ellos es GNOME con la librería de gráficos vectoriales llamada cairo. Por suerte, es posible incorporar su uso desde R a través del paquete “cairo”, y luego incluyendo el parámetro “type” en la función png():\ninstall.packages(\"cairo\")\nlibrary(cairo)\npng(filename=\"graphic.png\", units=\"in\", width=23.4, height=16.5, res=600, type=\"cairo-png\")\n    codigo de generación de la imagen aqui...\ndev.off()\nLayout de impresión\nEn muchos centros de impresión tienen el mismo precio, imprimir un pliego de tamaño A2 que uno de tamaño A0. En este caso es mucho más inteligente aprovechar todo el pliego A0, en el cual caben varias combinaciones (dos hojas A1, un A1 y dos A2 o cuatro A2). Para esto basta con ubicar nuestras imágenes en los tamaños y posiciones correctas.\n\nEsta tarea suele ser sencilla, el tema es que si nuestras imágenes son muy pesadas podríamos tener problemas para cargar varias de ellas en un software de dibujo cualquiera. Mi recomendación es utilizar herramientas de transformación de gráficos raster en línea de comandos, estoy hablando específicamente de imagemagick, software libre que podemos instalar en cualquier sistema operativo. Esta herramienta incluye un comando llamado convert que tiene entre su parámetros el append y rotate, que podemos usar para disponer adecuadamente nuestras imágenes en un formato A0.\nPor ejemplo si disponemos de 4 archivos de imágenes tamaño A2: clifford1.png y clifford2.png con orientación vertical, y dos imágenes lorenz1.png y mandelbrot1.png con orientación apaisada,\npodríamos usar el comando convert, para generar a partir de estos 4 archivos, uno solo en formato A0:\nconvert.exe +append clifford1.png Clifford2.png image01.png\nconvert.exe -append Mandelbrot1.png lorenz1.png image02.png\nconvert.exe -rotate 90 image02.png image03.png\nconvert.exe -append image01.png image03.png image04.png\n\n\n\n",
    "preview": "posts/2020-09-07-imgenes-de-fractales-en-gran-formato-con-r/../../images/fractales_galery.png",
    "last_modified": "2021-04-29T06:46:20+00:00",
    "input_file": {},
    "preview_width": 627,
    "preview_height": 318
  },
  {
    "path": "posts/2020-09-07-el-arte-del-movimiento-catico/",
    "title": "El arte del movimiento caótico",
    "description": "Un factor común de la mayoría de los fractales, es su poder de atraernos, de casi hipnotizarnos por su particular belleza, tal como si fueran verdaderas obras de arte. Los atractores de Clifford son un ejemplo del arte que puede representar el movimiento de los sistemas caóticos. De hecho, he comenzado preparar varios de estos gráficos en alta resolución, para compartirlos con ustedes y puedan ser impresos como posters si lo desean.",
    "author": [
      {
        "name": "José R Sosa",
        "url": "https://example.com/josersosa"
      }
    ],
    "date": "2020-03-19",
    "categories": [
      "Chaos and Fractals",
      "Computer Graphics"
    ],
    "contents": "\nUn factor común de la mayoría de los fractales, es su poder de atraernos, de casi hipnotizarnos por su particular belleza, tal como si fueran verdaderas obras de arte. Los atractores de Clifford son un ejemplo del arte que puede representar el movimiento de los sistemas caóticos.\nPéndulo Caótico\nRecordando el efecto mariposa, el péndulo doble es uno de los sistemas caóticos más simples. Si se lanza, dando posiciones iniciales ligeramente diferentes cada vez, se obtienen trayectorias completamente distintas.\nAtractores de Clifford\nOtras dinámicas inspiradas en este tipo de sistemas son las que generan los atractores de Clifford: \\[\nx_{n+1} = sin (a~y_n ) + c~cos (a~x_n ) \\\\\ny_{n+1} = sin (b~x_n ) + d~cos (b~y_n )\n\\]\nCon solo variar los parámetros a,b,c, y d es posible obtener una infinidad de atractores de increíble rareza y particular belleza, casi cómo si fueran verdaderas obras de arte. Haciendo algunas simulaciones en las que dibujamos las trayectorias con un poco de transparencia, es fácil notar que para ciertos parámetros,\nAtractor de Clifford\n\nse obtienen estructuras en las que las trayectorias tienden a cubrir todo el espacio de posibilidades, sin embargo la distribución no es uniforme.\nAlgunas trayectorias son mas probables que otras. Lo que se puede observar por la intensidad de esos trazos, gracias a ellas\nse generan imágenes que aparentan tener volumen tridimensional, a pesar de estar definidas y construidas y en 2 dimensiones.\nClifford Alan Pickover es un científico que dedicó gran parte de su vida a la divulgación de la ciencia, la visualización científica , al arte computacional y a las matemáticas recreativas. En sus propias palabras, planteó que “los datos … proliferan a un ritmo increíble, si los humanos intentan leer dichos datos en forma de números y letras, tomarán la información al ritmo de un caracol. Sin embargo, si la información se presenta gráficamente, los analistas humanos pueden asimilarla y obtener información mucho más rápido”1. En muchos sentidos, sus trabajos funcionaron para impulsar el “el arte y la ciencia de hacer visibles los trabajos invisibles de la naturaleza”2.\n\n\n\n",
    "preview": "posts/2020-09-07-el-arte-del-movimiento-catico/../../images/Clifford_peq_yelow02.png",
    "last_modified": "2021-03-14T17:00:32+00:00",
    "input_file": {},
    "preview_width": 595,
    "preview_height": 419
  },
  {
    "path": "posts/2020-09-07-el-infinito-detalle-del-conjunto-de-mandelbrot/",
    "title": "El infinito detalle del conjunto de Mandelbrot",
    "description": "La convergencia de los sistemas dinámicos complejos es un problema recurrente en muchos campos, su predictibilidad  en algunos casos pudiera estar involucrada con los conceptos de la geometría fractal y la teoría del caos. Escribí una breve reseña sobre uno de los fractales más conocidos vinculados con este tema: el conjunto de Mandelbrot.",
    "author": [
      {
        "name": "José R Sosa",
        "url": "https://example.com/josersosa"
      }
    ],
    "date": "2020-02-28",
    "categories": [
      "Chaos and Fractals",
      "Computer Graphics",
      "Data Science"
    ],
    "contents": "\n¿Cuánto mide la costa de Gran Bretaña? Parece una pregunta simple, pero su respuesta sorprendió a Benoît B. Mandelbrot: depende de cuán cerca se mire, “aquí hay una pregunta, un elemento básico de la geometría de la escuela primaria que, si lo piensas, es imposible” - dijo - “la longitud de la costa, en cierto sentido, es infinita”1.\nVeámoslo de la siguiente forma, pareciera sencillo medir la longitud en un mapa, pero si nos acercamos a ver con mayor detalle, descubriremos que no tomamos en cuenta muchos dobleces y cuencas, es decir que en realidad la distancia es un poco mayor de lo que creíamos. Pues bien, este efecto se repetirá siempre que veamos el mapa con mayor detalle, y es precisamente lo que ocurre con muchos objetos de la naturaleza, como las montañas, las nubes y en las matemáticas, cómo lo descubrió Mandelbrot con el conjunto que ahora lleva su nombre:\n\nEste objeto formado por todos los valores de condiciones iniciales para los cuales una determinada dinámica converge, nos muestra el infinito detalle que separa los valores que nos llevan a la convergencia, de aquellos que la hacen divergir: \\[\nz_{n+1}=z_n^2+c\n\\] Sorprende cómo una dinámica tan simple pueda generar una imagen tan fascinante, que muestra propiedades tan extrañas como la auto-similitud, vemos como las mismas formas se repiten y reaparecen a diferentes escalas.\nLa aparente contradicción entre la longitud del conjunto y su infinito detalle se resolvió con una sorprendente idea: este objeto no está en 2 dimensiones, evidentemente tampoco en 3, sino que pertenece a algún punto entre la 2da y 3ra dimensión, es decir, que pertenece a una dimensión fraccionaria o dimensión fractal, y de aquí, el por qué objetos como este adoptaron el nombre de Fractales. Piénsenlo bien, un perímetro o distancia es una medida unidimensional, calculada sobre un mapa (bidimensional), sin embargo, este objeto tiene un poco más de dos dimensiones por eso es imposible calcular su perímetro de manera exacta.\n¿Cuando y por qué algunas dinámicas matemáticas convergen mientras otras divergen?, o más aún ¿porque algunas dinámicas convergen bajo ciertas condiciones iniciales y divergen en otras? Como ven, la respuestas pueden llegar a ser más complejas de lo que pensábamos. Cuando estamos cerca del borde del conjunto, un punto podría converger mientras que otro infinitesimalmente cercano podría no hacerlo, en esta región se comporta como un sistema caótico.\nEstas son preguntas importantes cuando, por ejemplo, trabajamos en el entrenamiento de modelos de inteligencia artificial, en los cuales solemos usar algoritmos de entrenamiento o dinámicas como el descenso del gradiente. Esto respondería cuestiones como el por qué algunos sistemas tienen la capacidad de “aprender” mientras que otros no. O visto de otra forma, cómo diseñar sistemas de aprendizaje automático cuya dinámica de entrenamiento nos garantice la convergencia, es decir, aprender.\n\n\n",
    "preview": "posts/2020-09-07-el-infinito-detalle-del-conjunto-de-mandelbrot/../../images/Mandelbrot_red_peq.png",
    "last_modified": "2020-09-13T03:53:16+00:00",
    "input_file": {},
    "preview_width": 595,
    "preview_height": 419
  },
  {
    "path": "posts/2020-09-07-atractor-de-lorenz-y-el-efecto-mariposa/",
    "title": "Atractor de Lorenz y \"el efecto mariposa\"",
    "description": "El aparente desorden o aleatoriedad de los sistemas caóticos, es en realidad orden, tan exacto y matemático como impredecible e inexplicable. Escribí una breve reseña de una historia que vi cuando estudiaba en la universidad, sobre una de las características más interesantes de la teoría del caos: \"el efecto mariposa\".",
    "author": [
      {
        "name": "José R Sosa",
        "url": "https://example.com/josersosa"
      }
    ],
    "date": "2020-02-26",
    "categories": [
      "Chaos and Fractals",
      "Computer Graphics",
      "Data Science",
      "Simulation"
    ],
    "contents": "\nEn 1963 el matemático y meteorólogo Eduard N. Lorenz estaba experimentando con unas ecuaciones diferenciales ordinarias en un intento por simular una versión simplificada de una dinámica del clima. \\[\n\\begin{aligned}\n\\dot{x} & = \\sigma(y-x) \\\\\n\\dot{y} & = x(\\rho - z) - y \\\\\n\\dot{z} & = xy -\\beta z\n\\end{aligned}\n\\] En medio de la simulación, cuyos resultados se tenían que imprimir porque no se podían guardar en disco por esa época, se fue la luz. Una vez reestablecido el sistema, decidió continuar con la simulación pero no comenzando desde el principio, sino que tomó las condiciones iniciales en un punto intermedio de la secuencia que ya había creado. De esa forma ahorraría papel, tiempo y podría verificar que el sistema evolucionaría de la misma manera que lo había hecho antes. Sin embargo esto que parecía obvio, no ocurrió. Al cabo de un tiempo las secuencias original y la nueva comenzaron a separarse, y mucho. Se hicieron pruebas para intentar descubrir donde estaba el error, pero el hecho es que tanto el primer cálculo como el segundo seguían perfectamente las ecuaciones. El análisis gráfico mostró lo que realmente estaba ocurriendo:\n\nSin importar las condiciones iniciales que se escojan el resultado es el mismo\nLas tres variables, juntas en un gráfico de tres dimensiones, siempre tenderán a formar la figura de un atractor extraño de dos discos en 3D, que ahora conocemos como el atractor de Lorenz,\nSin embargo, estas trayectorias no son cíclicas, ya que estos caminos nunca se repiten.\nPor muy parecidas que sean dos trayectorias, estas tenderán a separarse radicalmente tarde o temprano, de hecho\nbasta una mínima diferencia “infinitesimal” entre lo dos caminos para que esto ocurra, que fue justamente lo que pasó en el experimento original, donde la variación estuvo en el orden de los decimales que no se pudieron imprimir.\nInspirado en la forma de este atractor extraño, Lorenz le dio nombre al famoso postulado de la teoría del caos: \"El efecto mariposa que dice que hasta el aleteo de una mariposa podría desencadenar eventos catastróficos en otra arte del mundo, como una poderosa tormenta.\n\nEsta imagen muestra como las trayectorias forman una patrón pero sin llegar a tocarse. Las líneas tienen el ancho de un pixel con anti-alising para maximizar el detalle en la versión impresa.\n\nEn esta imagen de detalle del atractor se observan trayectorias que parecen venir juntas y comienzan a separarse, algunas continúan en el mismo disco y otras pasan al otro.\nEs impresionante ver como esta complejidad pueda surgir de ecuaciones tan simples. Nos hace pensar que muchos fenómenos de la naturaleza aparentemente aleatorios pudieran ser caóticos, es decir, regidos por reglas matemáticas, y de ser así, sería más impactante aún, tener que aceptar que aunque conociéramos las ecuaciones que rigen a la naturaleza o el universo, no podríamos usarlas para predecir el futuro, ya que tendríamos que poder medir con infinita precisión el valor de las variables involucradas.\nEl aparente desorden o aleatoriedad de los sistemas caóticos, es en realidad orden, tan exacto y matemático como impredecible e inexplicable.\n\n\n\n",
    "preview": "posts/2020-09-07-atractor-de-lorenz-y-el-efecto-mariposa/../../images/lorenz_yelow11-10mm_peq.png",
    "last_modified": "2021-05-03T22:02:31+00:00",
    "input_file": {},
    "preview_width": 594,
    "preview_height": 420
  },
  {
    "path": "posts/2021-04-29-programando-en-r-taller-interactivo/",
    "title": "Taller interactivo: Programando en R",
    "description": "Aún hoy en día, existe mucho contenido para la formación en Ciencia de Datos y particularmente sobre R en diversos formatos y repositorios, sin embargo, la mayoría de ellos están en ingles...",
    "author": [
      {
        "name": "José R Sosa",
        "url": "https://example.com/josersosa"
      }
    ],
    "date": "2015-10-11",
    "categories": [
      "R",
      "Data Science",
      "Teaching"
    ],
    "contents": "\n\nContents\n¿Que es Swirl?\nObjetivo\nPrerrequisitos\n¿Como ejecutar el curso?\nAvance del proyecto\n\nTODOs\n\n¿Que es Swirl?\nEl paquete de R swirl(“Learn R, in R”) permite crear cursos interactivos que se ejecutan desde la propia consola de R, por lo cual el estudiante puede ejecutar la instrucciones directamente en R en la medida que avanza su curso. Existen varios cursor en el repositorio de swirl, pero todos están en ingles.\nObjetivo\nEl objetivo de este proyecto es disponer un curso interactivo sobre los fundamentos de la programación en R, en el idioma español para aquellos hispanohablantes interesados en aprender este lenguaje de programación. Para esto se traducirá el curso R_Programming_Alt del swirl.\nPrerrequisitos\nPara acceder a este curso debes tener instalado el R, y preferiblemente Rstudio, así como el paquete swirl. Puedes instalarlo desde la consola de R así:\n\n\ninstall.packages('swirl')\n\n\n\n¿Como ejecutar el curso?\nPara realizar este curso debemos primero instalarlo desde su repositorio en github en la consola de R, así:\n\n\nlibrary(swirl)\ninstall_course_github('josersosa','Programando_en_R')\n\n\n\nY lo iniciamos con:\n\n\nswirl()\n\n\n\nAl comienzo nos solicita un nombre para identificarnos y almacenar los avances que hagamos en el caso que deseemos pausar el curso. Las primeras informaciones estan en ingles porque provienen del paquete swirl. Luego seleccionamos el curso Programando en R y a partir de ahí todo lo esencial estará traducido.\nPor último, cuando hayamos terminado, podemos desinstalar el curso con:\n\n\nuninstall_course(\"Programando_en_R\")\n\n\n\nAvance del proyecto\nHasta ahora, este proyecto tiene una avance del 100% en la traducción. Están traducidas todas las lecciones de un total de las 12 del curso original R_Programming_Alt. Ya se han incluido la lecciones extraspara hacer nuestro curso en español un poco más completo:\nWorkspace_and_Files.\nFunctions.\nBase_Graphics. Se incluyó la función barplot y algunos comentarios\nTODOs\nReconfigurar los directoris con los títulos en español.\nIncluir las lecciones del curso R Programming de swirl para hacer nuestro curso en español un poco más completo:\nWorkspace_and_Files.\nFunctions.\nBase_Graphics.\nPor otra parte, intentaré incluir al final de cada lección, aparte del envío del correo, la opción de calificar mediante una conección a alguna aula virtual basada en moodle.\n\n\n\n",
    "preview": "posts/2021-04-29-programando-en-r-taller-interactivo/../../images/R-Programming-Language.jpg",
    "last_modified": "2021-04-29T20:58:58+00:00",
    "input_file": {}
  },
  {
    "path": "posts/2021-05-03-edicin-de-videos-en-lnea-de-comandos-con-ffmpeg/",
    "title": "Edición de videos en línea de comandos con FFmpeg",
    "description": "Hace algún tiempo utilicé [FFmpeg](http://www.ffmpeg.org/) para la automatización de la grabación de algunos tutoriales y por eso quedé con la inquietud de crear un breve turtorial con algunas de sus principales funciones.",
    "author": [
      {
        "name": "José R Sosa",
        "url": "https://example.com/josersosa"
      }
    ],
    "date": "2013-11-10",
    "categories": [
      "Linux Recipes"
    ],
    "contents": "\n\nContents\nComponentes de FFmpeg\nParámetros de uso del ffmpeg\n\nEjemplos de uso de ffmepg.\nGrabación de la entrada de video de la WebCam\nDos formas de grabación de sonido, usando OSS o ALSA\nConversión de formatos de audio, por ejemplo de wav a ogg\nConversión de formatos de video\nConversión de video a imágenes, este ejemplo creará 25 imágenes por segundo\nConversión de imágenes a video\nDos formas de grabación de la entrada de video y audio por la WebCam y el micrófono\nConvertir video a imágenes animadas GIF\nConvertir GIF a video\nUnir audio y video\nConcatenar videos\nConcatenar varios videos haciendo recodificación\nCambiar resolución de video\nCortar un video\nTrabajar por lotes\nRedimensionar video agregando un marco negro\nRotar videos\n\nGrabación de la pantalla del escritorio Linux con sincronización del audio y el video (ScreenCast):\nAutomatización de la producción de ScreenCast:\nEl script para iniciar el screencast\nEl script para finalizar el screencast\n\nEl efecto Chroma key\nEjemplos de uso ffplay.\nDespliegue de la entrada de video de la WebCam:\nPara simplemente reproducir un video:\n\nStreaming de video con ffserver.\nCompilando ffmpeg desde las fuentes.\nFuentes.\n\nFFmpeg es un completo y muy avanzado conjunto de herramientas de software libre orientadas al procesamiento de video desde consola. Contempla aplicaciones para la grabación, reproducción, conversión, transcodificación y streaming de video. Además contiene un amplio conjunto de codecs y librerías de audio y video que lo convierten en una herramienta de desarrollo indispensable, así como tremendamente útil para la creación y manipulación de nuestros videos, la extracción o incorporación de audio, transferencia de video por red (streaming) e incluso la creación de ScreenCast para videotutoriales.\ngif de ejemplo del efecto chroma key con ffmpegComponentes de FFmpeg\nEl proyecto FFmpeg viene con varios programas pero podríamos decir que los más importantes son ffmpeg, ffserver y ffplay.\nParámetros de uso del ffmpeg\nEl ffmpeg esta orientado fundamentalmente la grabación, transcodificación y conversión de videos. Permite entre otras cosas, convertir entre una amplia gama de formatos, pasando por la extracción de imágenes y sonido de nuestros videos o la conversión de imágenes indexadas a videos. Los principales parámetros de este programa son:\n-i dispositivo de entrada tanto para vídeo como para audio.\n-f formato de entrada de vídeo o de audio.\n-r n consigue que se haga la grabación n fotogramas por segundo.\n-b se usa para estipular la tasa de bits por segundo a usar en la salida ya sea de vídeo o sonido, ejemplo: -b 128k.\n-sameq consigue que se haga la captura con la misma calidad que tenga la propia entrada. Haciendo que la tasa de bits por segundo de la salida sea la necesaria como para que no sea apreciable ninguna pérdida de calidad con respecto a la entrada. Si usas esta opción, no es necesario usar -b.\n-async n para conseguir una buena sincronización del sonido de entrada y la imagen. De este modo, si grabamos nuestra voz mientras grabamos el vídeo veremos como nuestras palabras van en sincronía con el vídeo.\n-s tamaño o resolución de la captura de pantalla, puede ser indicado de la forma 640x480 o bien su equivalente vga. El listado completo de resoluciones admisibles es el siguiente:\n  wsxga: 1600×1024\n  wuxga: 1920×1200\n  woxga: 2560×1600\n  wqsxga: 3200×2048\n  wquxga: 3840×2400\n  whsxga: 6400×4096\n  whuxga: 7680×4800\n  cga: 320×200\n  ega: 640×350\n  hd480: 852×480\n  hd720: 1280×720\n  hd1080: 1920×1080\n  16cif: 1408×1152\n  qqvga: 160×120\n  qvga: 320×240\n  vga: 640×480\n  svga: 800×600\n  xga: 1024×768\n  uxga: 1600×1200\n  qxga: 2048×1536\n  sxga: 1280×1024\n  qsxga: 2560×2048\n  hsxga: 5120×4096\n  wvga: 852×480\n  wxga: 1366×768\n  sqcif: 128×96\n  qcif: 176×144\n  cif: 352×288\n  4cif: 704×576\nEjemplos de uso de ffmepg.\nA continuación podemos ver algunos ejemplos del uso de estas herramientas:\nGrabación de la entrada de video de la WebCam\nffmpeg -f video4linux2 -s 320x240 -i /dev/video0 -sameq ./out.mpg\nDos formas de grabación de sonido, usando OSS o ALSA\nffmpeg -f oss -i /dev/dsp salida.mpg\nffmpeg -f alsa -i plughw:1,0 salida.mpg\nConversión de formatos de audio, por ejemplo de wav a ogg\nffmpeg -i my_audio.wav my_audio.ogg\nConversión de formatos de video\nffmpeg -i my_video.flv my_video.mpeg\nffmpeg -i my_video.mpeg -s 500×500 my_video.flv\nffmpeg -i input_file_name.mp4 -vcodec flv -ar 22050 output_file_name.flv\nCuando convertimos videos a formatos comprimido es posible que se reduzca la calidad de la imagen, para evitar esto podemos usar el parámetro -qscale 0 donde el cero indica que se debe mantener la calidad en la medida de lo posible:\nffmpeg -i my_video.avi -qscale 0 my_video.mp4\nConversión de video a imágenes, este ejemplo creará 25 imágenes por segundo\nffmpeg -i test.mpg -r 25 image%d.jpg\nffmpeg -i test.mpg -r 25 -ss 00:00:10 -t 00:00:05 images%05d.png\nConversión de imágenes a video\nffmpeg -f image2 -i img%d.jpg /tmp/a.mpg\nDos formas de grabación de la entrada de video y audio por la WebCam y el micrófono\nffmpeg -f video4linux2 -s 320x240 -i /dev/video0 -f audio_device -ac 2 -i /dev/dsp1 -f mp4 Filename.mp4\nffmpeg -f oss -i /dev/dsp -f video4linux2 -s 320x240 -i /dev/video0 out.mpg\nConvertir video a imágenes animadas GIF\nffmpeg -ss 7.0 -t 5.5 -i video.mp4 -f gif image.gif\nEntonces, con estos dos argumentos, FFmpeg buscará segundo 7.0 y leerá en los próximos 5.5 segundos para la creación del GIF. Otra forma de hacer esto para lograr un mejor resultado es combinar FFmpeg con Imagemagick en el siguiente pipeline:\nffmpeg -i video.mp4 -vf \"fps=10,scale=320:-1:flags=lanczos\" -c:v pam -f image2pipe - | convert -delay 10 - -loop 0 -layers optimize output.gif\nConvertir GIF a video\nffmpeg -i image.gif -f mp4 -pix_fmt yuv420p video.mp4\nEntonces, con estos dos argumentos, FFmpeg buscará segundo 7.0 y leerá en los próximos 5.5 segundos para la creación del GIF.\nUnir audio y video\nffmpeg -i audio.mp3 -i video.mpg -sameq video.mkv\nffmpeg -i audio.mp3 -i video.mpg -sameq video_result.mpg\nConcatenar videos\nffmpeg -f concat -i file video1.mpg file video2.mpg -c copy video.mpg \nffmpeg -i \"concat:video1.mpg|video2.mpg\" -c copy video.mpg\nffmpeg -i \"concat:$1|$2\" -c copy $3\nffmpeg -f concat -safe 0 -i video.txt video.mp4\nConcatenar varios videos haciendo recodificación\nffmpeg -i video1.mp4 -i video2.mp4 -i video3.mp4 \\\n  -filter_complex '[0:v:0] [0:a:0] [1:v:0] [1:a:0] [2:v:0] [2:a:0] concat=n=3:v=1:a=1 [v] [a]' \\\n  -map '[v]' -map '[a]' output2.mkv\nCambiar resolución de video\nffmpeg -i video.mp4 -vf scale=1280:766 video_1280x766.mp4 -hide_banner -qscale 0\nffmpeg -y -i video.mp4 -vf scale=1440:900,setsar=1:1 -c copy video2.mp4 -hide_banner\nCortar un video\nffmpeg -i video.mpg -ss 00:00:02.000 -to 00:00:42.068 -c copy -copyts video_corto.mpg\nTrabajar por lotes\n# Conversión de formato por lotes\nfor FILE in *.{AVI,mpg} ; do \\\\\n    NAME=`echo \"$FILE\" | cut -d'.' -f1`; \\\\\n    ffmpeg -i $FILE -qscale 0 $NAME.mkv; \\\\\n    done\nRedimensionar video agregando un marco negro\n-vf \"scale=640:-1\" \n-vf \"scale=640x360,pad=640:480:0:60:black\"\nffmpeg -i input.jpg -vf scale=w=320:h=240:force_original_aspect_ratio=decrease output_320.png\nffmpeg -y -i video.mp4 -aspect 16:9 scale=640x360,pad=640:480:0:60:black video_2.mp4\nffmpeg -i video.mp4 -vf scale=640:480,pad=1024:600:192:60:black -qscale 0 video_2.mp4\n/opt/ffmpeg/ffmpeg -i CIMG1169_.mp4  -vf scale=800:600,pad=1024:600:112:0:black  CIMG1169_2.mp4\nRotar videos\nffmpeg -i original.avi -vf \"transpose=1\" resultado.avi\nEl valor del parámetro transpose indica el tipo de transformación, siendo 1 una rotación de 90 grados en el sentido de las agujas del reloj. El valor 2 giraría 90 grados en sentido contrario.\nPara el parámetro de transposición puede pasar:\n0 = 90CounterCLockwise and Vertical Flip (default)\n1 = 90Clockwise\n2 = 90CounterClockwise\n3 = 90Clockwise and Vertical Flip\nÚselo -vf \"transpose=2,transpose=2\"para 180 grados. Otras dos transformaciones interesantes en esta misma línea que podemos aplicar mediante el argumento -vf son mirror y flip. Si queremos girar el vídeo 180 grados podemos aplicarlas ambas de modo conjunto (-vf mirror,flip).\nGrabación de la pantalla del escritorio Linux con sincronización del audio y el video (ScreenCast):\nUn ScreenCast es al vídeo lo que un SnapShot (pantallazo o captura de pantalla) a la fotografía. Hay algunos programas que realizan capturas de vídeo de lo que se muestra en nuestra pantalla, unos con mejores resultados que otros y también con mayor o menor dificultad de uso. Ejemplo de ello son Istanbul y RecordMyDesktop, dos soluciones que podrían funcionar muy bien. Sin embargo, no nos permiten grabar sonido de un micrófono mientras graba la pantalla, para por ejemplo dar un videotutorial, cosa que si podemos hacer con FFmpeg. A continuación muestro un ejemplo de como hacer esto, grabando un video de nuestra pantalla a 25 imágenes por segundo. El video se captura desde la esquina superior izquierda de la pantalla, y en este caso, hasta la coordenada 800x600:\nffmpeg -async 1 -f alsa -i plughw:1,0 -f x11grab -s 800x600 -r 25 -i :0.0 -b 128k ./out.mpg\nffmpeg -async 1 -f alsa -i plughw:1,0 -f x11grab -s 800x600 -r 25 -i :0.0 -sameq ./out.mpg\nffmpeg -async 1 -f alsa -i plughw:1,0 -f x11grab -s 800x600 -r 25 -i :0.0 -qscale 0 ./out.mpg\nffmpeg \\ \n    -async 1 \\\n    -f oss \\\n    -i /dev/dsp1 \\\n    -f x11grab \\\n    -s 1024x600 \\\n    -framerate 20 \\\n    -i :0.0 \\\n    -sameq \\\n    /root/video.mpg\nAutomatización de la producción de ScreenCast:\nPara la automatización de nuestros Screecast haremos uso de 2 herramientas (ffmpeg para realizar la captura de la pantalla y xwininfo para obtener las coordenadas y dimensiones de la ventana a grabar). Podemos realizar screencasts utilizando recursos mínimos y obteniendo óptimos resultados.\nEl script para iniciar el screencast\n\\#!/bin/bash\n\n\\# Obtener las coordenadas y el tamaño de la ventana seleccionada\n\\# Esto excluye la decoración de la ventana.\n unset x y w h\n eval $(xwininfo -frame |\n  sed -n -e \"s/^ +Absolute upper-left X: +([0-9]+).*/x=1/p\"\n      -e \"s/^ +Absolute upper-left Y: +([0-9]+).*/y=1/p\"\n      -e \"s/^ +Width: +([0-9]+).*/w=1/p\"\n      -e \"s/^ +Height: +([0-9]+).*/h=1/p\" )\n$w=$w + $w % 2 # que el ancho sea múltiplo de 2, sino ffmpeg se queja\nWIN_XY=$x\",\"$y # dar formato a las coordenadas XY\nWIN_GEO=$w\"x\"$h # dar formato al tamaño de la ventana\n\\# notify-send mostrará un mensaje indicando el inicio del screencast.\n\\# correr ffmpeg con los parámetros que se ajusten a tu configuración.\nnotify-send \"Iniciando screencast...\" && ffmpeg -f alsa -i hw:0 -f x11grab -r 25 -s $WIN_GEO -i :0.0+$WIN_XY -acodec libmp3lame -async 1 -vcodec libx264 -preset ultrafast -crf 0 -threads 0 guardar.mp4\nNo hace falta entender completamente este scripts más allá de que genera una archivo de salida llamado guardar.mp4. Para obtener resultado, sin embargo, es necesario poder hacer ciertos cambios como:.\nSi usás OSS, reemplazaremos -f alsa -i hw:0 por -f oss -i /dev/dsp\nSi usamos solo ALSA, tenés que usar los parámetros que vienen en el script (-f alsa -i hw:0). Para determinar el número que va después de hw: podemos ejecutar aplay -l y elegir el número de la tarjeta de sonido adecuada.\nSi usás Pulse Audio (Ubuntu y derivados usan esto), usá los parámetros -f alsa -ac 1 -i pulse.\nPara varias las cantidad de frames por segundo (FPS): -r 25 indica los fps a los que deseemos grabar. 25 es una buena opción.\nCon respecto al los Códec de audio, video y sincronización\n-acodec libmp3lame es el códec de audio. Lo elegí grabar en mp3. Podemos utilizar cualquier otro.\n-async 1 permite la sincronización del audio con el video.\n-vcodec libx264 -preset ultrafast -crf 0 -threads 0, le indica a ffmpeg que el códec de video a utilizar sea x264 y que el preset sea ultrafast (hay fast, slow, etc), de lo contrario no llega a grabar correctamente a la cantidad de fps deseados. El parámetro -crf 0 indica el nivel de compresión (cuanto más bajo, menor la compresión). Por último, threads 0 indica la cantidad de hilos a utilizar, al pasar 0 ffmpeg lo calcula automáticamente. Al igual que con la configuración de audio, podemos elegir otras opciones.\n\nTodas estas configuraciones fueron las que dieron mejores resultados: un archivo relativamente pequeño, una buena calidad de video, con audio sincronizado y sin lags. No obstante, te recomiendo sumergirte en la documentación de ffmpeg para descubrir otras.\nEl script para finalizar el screencast\n#!/bin/bash\nnotify-send \"Finalizando screencast...\" && killall ffmpeg\nPara que ambos scripts funcionen debemos tener instalado notify-send. La mayoría de las distribuciones deberían venir con esta herramienta instalada. En Arch y derivados: sudo pacman -S libnotify.\nEl efecto Chroma key\n/opt/ffmpeg/ffmpeg \\\n   -i image_fondo.jpg \\\n   -i video.AVI \\\n   -filter_complex \\\n      \"[1:v]chromakey=0x004682:0.15:0.0[keyed]; \\\n      [0:v][keyed]overlay[out]\" \\\n   -map \"[out]\" \\\n   -vcodec libx264 \\\n   -crf 18 \\\n   -preset slower \\\n   video_result.avi \nEjemplos de uso ffplay.\nPor otra parte ffplay fue creado como un reproductor de video. El uso de ffplay es muy simple, aquí podemos ver unos ejemplos:\nDespliegue de la entrada de video de la WebCam:\nffplay -f video4linux2 -i /dev/video0 >/dev/null &\nPara simplemente reproducir un video:\nffplay out.mpg\nStreaming de video con ffserver.\nEl ffserver es una herramienta diseñada para servir el streaming de video, por ejemplo podemos usar la webcam en streaming para poder conectarnos desde cualquier lugar con el smartphone. FFmpeg maneja una gran cantidad de formatos en los que se puede emitir, además de ser relativamente fácil de configurar. La emisión del streaming se basa en el uso de dos programas: ffserver y ffmpeg. El primero se ejecuta en modo escucha y se encarga de hacer el streaming real mientras que el segundo recoge la imagen de alguna fuente y la envía a al primero.\nPara empezar, es necesario crear un archivo de configuración: /etc/ffserver.conf, dejándolo como así:\nPort 8090\nBindAddress 0.0.0.0\nMaxHTTPConnections 2000\nMaxClients 1000\nMaxBandwidth 1000\nCustomLog -\n\n<Feed webcam.ffm>\n  File /tmp/webcam.ffm\n  FileMaxSize 35M\n<\/Feed>\n\n<Stream webcam.swf>\n  Feed webcam.ffm\n  Format swf\n  VideoBitRate 320\n  VideoFrameRate 10\n  VideoSize 640x480\n  NoAudio\n  VideoQMin 1\n  VideoQMax 3\n<\/Stream>\n\n<Stream stat.html>\n  Format status\n<\/Stream>\n\n<Redirect index.html>\n  URL http://www.ffmpeg.org/\n<\/Redirect>\nUna vez configurado, es necesario iniciar el servicio con el comando:\nffserver -f ffserver.conf\nAhora sólo quedaría enviar la imagen al servidor con el comando ffmpeg y se puede utilizar cualquier entrada para redireccionarla al servidor. Por ejemplo, en el caso de una webcam, una capturadora de TV o cualquier entrada de vídeo, el comando sería:\nffmpeg -r 15 -s 320x240 -f video4linux -i /dev/video0 http://localhost:8090/webcam.ffm\nEn algunos casos podemos encontrarnos con este error:\n[flv @ 0x97df6f0]rc buffer underflow VIDIOCMCAPTURE: Invalid argument\nPara solucionar el problema, debemos escribir antes del comando ffmpeg, lo siguiente :\nLD_PRELOAD=/usr/lib/libv4l/v4l1compat.so\nSi todo va bien, podremos ver la imagen emitida con el navegador.\nCompilando ffmpeg desde las fuentes.\nEl sistema FFmpeg viene incluido en casi todos los repositorios oficiales de las principales distribuciones de GNU/Linux, sin embargo no siempre están compilados con todas las funciones que deseamos (con el dispositivo de grabación x11_grab por ejemplo) o, en ocaciones excepcionales, querremos preparar una nueva versión para nuestro sistema operativo. De cualquier modo es importante tener una breve receta de como compilar el FFmpeg desde las fuentes. Lo primero será descargar las fuentes, para esto lo mejor será ir a la zona de descargas de su sitio oficial: www.ffmpeg.org. Para el momento de escribir este artículo, la última versión es http://www.ffmpeg.org/releases/ffmpeg-2.1.tar.gz luego lo descomprimimos en algún directorio temporal, configuramos y compilamos así:\ntar zxvf ffmpeg-2.1.tar.gz\ncd ffmpeg-2.1.tar.gz\n./configure --enable-gpl --enable-version3 --enable-nonfree --enable-postproc --enable-libfaac --enable-libmp3lame --enable-libtheora --enable-libx264 --enable-libxvid --enable-x11grab --enable-libvorbis --enable-libvpx --enable-shared --enable-libopencore-amrnb --enable-libopencore-amrwb --enable-libschroedinger --enable-libopenjpeg --enable-runtime-cpudetect\nmake\nmake install\nEs importante verificar antes de compilar que el resultado de la configuración de las fuentes, reconoció como uno más de los dispositivos de grabación incorporados el x11_grab_device dentro de los “Enabled indevs”, debería verse algo así:\nEnabled indevs:\nalsa          oss           v4l2\ndv1394         v4l           x11_grab_device\nEn el caso de sistemas Debian o derivados, antes que nada deberemos actualizar nuestro archivo /etc/apt/sources.list agregando:\ndeb-src http://www.deb-multimedia.org sid main\ndeb http://www.deb-multimedia.org wheezy main non-free\nSalvamos y actualizamos los indices de los paquetes disponibles:\napt-get update\napt-get install deb-multimedia-keyring\nDespués de esto recomiendan borrar la linea deb “http://www.deb-multimedia.org wheezy main non-free” del archivo /etc/apt/sources.list Luego podremos descargar el paquete ya preparado denominado ffmpeg-dmo y luego se procede a compilar como de costumbre:\napt-get install libxfixes-dev\napt-get source ffmpeg-dmo\ncd ffmpeg-dmo-0.11\n./configure\nmake && make install\nFuentes.\nEste post fue realizado sobre la vase de varios artículos publicados y algunas de mis experiencias previas (espero no olvidar ninguna de las fuentes): http://www.juanluperez.com/index.php/2010/09/screencast-con-ffmpeg-y-grabacion-de-microfono/ http://soledadpenades.com/2010/04/26/unknown-input-or-output-format-x11grab-ubuntu/ http://dmnet.bitacoras.com/archivos/software/streaming-de-una-webcam-con-ffmpeg.php http://www.freetux.com.ar/como-grabar-screencast-por-terminal-usando-ffmpeg/ http://sirlagz.net/2012/08/04/how-to-stream-a-webcam-from-the-raspberry-pi/ http://blog.giuseppeurso.net/raspberry-keychain-808-3-as-webcam/index.html http://www.raspberrypi-es.com/category/ffmpeg/ http://soledadpenades.com/2010/04/26/unknown-input-or-output-format-x11grab-ubuntu/ https://engineering.giphy.com/how-to-make-gifs-with-ffmpeg/ https://trac.ffmpeg.org/wiki/Concatenate https://ffmpeg.org/ffmpeg-filters.html#chromakey http://oioiiooixiii.blogspot.com/2016/02/ffmpeg-chromakey-filter-filthy-frank.html http://johnvansickle.com/ffmpeg/ https://blog.unlugarenelmundo.es/2012/12/26/chuletillas-y-xxxvi-rotar-videos-con-mencoder/\n\n\n\n",
    "preview": "posts/2021-05-03-edicin-de-videos-en-lnea-de-comandos-con-ffmpeg/../../images/video-chroma-demo.png",
    "last_modified": "2021-05-08T14:31:39+00:00",
    "input_file": {},
    "preview_width": 929,
    "preview_height": 528
  },
  {
    "path": "posts/2021-04-30-la-mquina-de-galton-del-caos-al-orden/",
    "title": "La máquina de Galton, del Caos al Orden...",
    "description": "La \"Maquina de Galton\" es el nombre de un famoso experimento, que a pesar de estar completamente gobernado por el azar, muestra claramente como se presenta siempre la misma tendencia o distribución de los resultados.",
    "author": [
      {
        "name": "José R Sosa",
        "url": "https://example.com/josersosa"
      }
    ],
    "date": "2012-11-04",
    "categories": [
      "R",
      "Data Science",
      "Teaching",
      "Simulation",
      "Statistic"
    ],
    "contents": "\n\nContents\nFrancis Galton\nLa “Máquina de Galton”\nImportancia de este experimento\n¿Por qué ocurre esto?\nFormulación matemática\nSimulación de la Máquina de Galton en R\n\nAunque considero que el título de este video esta mal escogido, debido a que el caos no es desorden, sino orden. Este es un video que me gusta mostrar a los estudiantes al comienzo del tema de variables aleatorias, porque ejemplifica bastante bien la connotación empírica de las funciones de probabilidad.\nFrancis Galton\nSir Francis Galton (1822 - 1911) fue un antropólogo y geógrafo inglés. Estudió medicina en el hospital de Birmingham, en Londres y en Cambridge. Primo el gran Charles Darwin, que luego de muchos viajes se dedico a la investigación científica en el área de la geografía y la meteorología. Luego, inspirado por la publicación del Origen de las especies, se dedico en parte de su vida a teoría de la herencia y estadística demográfica.\nLa “Máquina de Galton”\nEste experimento consiste de una distribución de clavos o alfileres en forma triangular, de manera que al soltar un número de bolitas desde la cúspide de la estructura, caen chocando con estos alfileres. Cada bolita chocará con el primer clavo teniendo una probabilidad de 1/2 de ir hacía la izquierda o hacía la derecha, y así sucesivamente con los otros alfileres de los siguientes niveles. A lo largo de esta estructura, las bolitas toman caminos aleatorios hasta caer en alguno de los canales o bandejas colocadas en la base. El siguiente es un video de la máquina de Galton en acción:\n\n\nAl final, como se observa en el video, tendrán mayores probabilidades los canales interiores que los exteriores, formándose una distribución de probabilidades conocida como Binomial, que si el número de pelotas es suficientemente grande puede aproximarse por una distribución Normal o Gaussiana. Esta es justamente, la distribución que se encuentra dibujada sobre la máquina a modo de predicción de los resultados.\nImportancia de este experimento\nCuando nos enfrentamos a escenarios gobernados por el azar, como lo pueden ser muchas situaciones en economía, finanzas, opinión pública, redes sociales, marketing, etc. Generalmente sentimos que es como lanzar una moneda (50-50) y nuestra intuición nos dice que no podemos predecir lo que ocurrirá, por lo que no se puede tomar ninguna decisión fundamentada. Sin embargo, como se ha demostrado muchas veces, la estadística puede llegar a ser contra-intuitiva.\nSi bien no podemos predecir los resultados exactos, como lo sugiere la Maquina de Galton, muchos de estos escenarios siguen patrones. Conociendo estos patrones podemos hacer inferencias y tomar decisiones acertadas, siempre que entendamos y manejemos adecuadamente los márgenes de error de nuestras predicciones.\n¿Por qué ocurre esto?\nIntuitivamente podemos ver que la trayectoria de cada bolita es una secuencia de “decisiones” entre ¿izquierda o derecha?, cuyas posibilidades se reducen a medida que nos acercamos a las bandejas de los extremos. Tomemos por ejemplo la primera bandeja de la izquierda, para poder llegar a ella, una bolita tendría que tomar la misma decisión a lo largo de toda su trayectoria (izquierda, izquierda, izquierda,….) es decir que hay una sola forma o camino para llegar a esta bandeja. Por otro lado las bandejas del centro tienen muchos más caminos para llegar a ellas. Podemos suponer que la cantidad de bolitas que terminaran en cada bandeja, será proporcional a la cantidad de caminos posibles que hay para llegar a ellas.\nNota: Si no estas interesado en la matemática o simulación computacional, puedes leer hasta aquí.\nFormulación matemática\nSupongamos que la pirámide de alfileres conta de \\(n\\) niveles, es decir que esto corresponde las \\(n\\) decisiones que debe tomar cada bolita para llegar a alguna bandeja, por lo tanto debe haber al final \\(n+1\\) bandejas enumeradas desde el \\(0\\) al \\(n\\).\nPara representar las trayectorias de cada bolita, digamos que la decisión de ir por la izquierda es un 0 y la derecha es un 1, llamemos \\(D\\) a la variable aleatoria Bernoulli que representa cada decisión: \\[\nD=\\left\\{ \\begin{array}{lcc}\n             0 &   izquierda\n             \\\\ 1 &  derecha\n             \\end{array}, luego ~ D \\sim Bernoulli(p=1/2) \n   \\right.\n\\] Entonces cada trayectoria es independiente de las otras y se puede representar como un secuencia de \\(n\\) decisiones independientes, a su vez: \\[\nTrayectoria =\\left\\{d_1, d_2,...,d_n\\right\\}\n\\] por ejemplo: \\[\nTrayectoria =\\left\\{0, 1, 1, 0,...,1\\right\\}\n\\] Es fácil notar que la bandeja final de una bolita corresponderá a las suma de las \\(n\\) decisiones tomadas durante su trayectoria: \\[\nBandeja = \\sum_{i=1}^n{d_i}\n\\] Por ejemplo, como comentamos antes, si siempre se toma la decisión de ir por la izquierda, la bandeja final será el resultado de sumar \\(n\\) ceros: 0, es decir la primera bandeja, así, si el caso fuera tomar siempre la derecha, la suma de las decisiones daría \\(n\\) (la última de la derecha).\nEn este escenario podemos decir que la cantidad final de bolitas en cada bandeja será proporcional a la cantidad de trayectorias diferentes que llegan a ella, por lo tanto, para hallar una formulación matemática de la probabilidad de cada bandeja, pasa por contar estas trayectorias, para lo que usaremos la teoría combinatoria.\nDigamos que la bandeja final se representa por una variable aleatoria \\(X\\), para formularla, entre las bandejas de la \\(0\\) a la \\(n\\), escogemos una bandeja, digamos \\(x\\). Sabemos que para llegar a ella se tomaron \\(n\\) decisiones que incluyeron \\(x\\) unos y, por lo tanto, \\((n-x)\\) ceros, es decir, que la probabilidad de una trayectoria es el producto de la probabilidad de cada decisión: \\(p^x (1-p)^{n-x}\\). Solo faltaría saber cuantas trayectorias llegan a ella, eso lo sabemos por las posibles combinaciones de \\(x\\) unos y \\((n-x)\\) ceros, luego la probabilidad de la bandeja \\(X\\) es: \\[\nP(X)   = {n \\choose x} p^x (1-p)^{ n-x}\n\\] Que es un distribución de probabilidad conocida como Binomial, cuyos parámetros son n y p: \\[\nX \\sim Binomial(n, p)\n\\]\nDado que \\(X\\) se puede interpretar como la suma de n variables aleatorias independientes (las decisiones), cuando el parámetro n es grande, se cumple el conocido Teorema del Límite Central, lo que propone que la distribución de la variable aleatoria \\(X\\) se aproxima asintóticamente a una Normal: \\[\nX \\sim Binomial(n, p) \\approx Normal(\\mu, \\sigma^2)\n\\] donde \\(\\mu=np\\) y \\(\\sigma^2=np(1-p)\\), la esperanza matemática y la varianza de la Binomial, respectivamente.\nSimulación de la Máquina de Galton en R\nLlegamos a la parte fácil, para simular la Maquina de Galton vamos a simular las bolitas generando un número grande de trayectorias, que serán secuencias de n ceros y unos, seleccionados aleatoriamente con una probabilidad p para cada decisión:\n\n\nbolitas <- 10000 # catidad de bolitas\nn <- 30          # numero de niveles\np <- .5          # probabilidad de decision\nbandejas <- replicate(bolitas, # el numero de bolitas o trayectorias\n                      sum( sample(c(0,1), n, prob=c(0.5, 0.5), replace = TRUE) )) # suma sobre cada trayectoria\n\n\n\nLuego, para representar las bandejas donde caen las bolitas, calculamos la bandeja resultante de cada trayectoria, sumando las decisiones contenidas en cada una, todo esto lo hacemos con la función replicate. Con esto generamos un vector de las bandejas resultantes. Solo queda contar cuantas bolitas cayeron en cada bandeja y graficar la distribución, esto lo haremos con el histograma de este vector:\n\n\nhist(bandejas,               # distribucion del resultado de las bandejas\n     prob = TRUE,            # graficamos proporciones de las frecuencias\n     breaks = c(0:n+1)-0.5)  # resto 0.5 para centrar las clases en cada bandeja\nx <- seq(1,30, length.out = 100)                # generamos 100 puntos en el rango\ny <- dnorm(x, mean = n*p, sd = sqrt(n*p*(1-p))) # Funcion de dencidad de la normal \nlines(x, y, col = \"red\") # dibujamos la curva de la normal en rojo\n\n\n\n\nY obtenemos el mismo resultado que vimos en el video. Agregué a la gráfica la curva de la distribución normal para demostrarles como la aproximación a esta distribución se cumple a la perfección. Nota: Se puede ejecutar este cógigo en R varias veces para generar secuencias de trayectorias distintan y comprobar que simpre se cumple el mismo patrón.\n\n\n\n",
    "preview": "posts/2021-04-30-la-mquina-de-galton-del-caos-al-orden/../../images/simulacion-dalton.png",
    "last_modified": "2021-05-03T21:39:25+00:00",
    "input_file": {},
    "preview_width": 1248,
    "preview_height": 768
  },
  {
    "path": "posts/2021-05-08-como-verificar-puertos-y-procesos-en-linux/",
    "title": "Cómo verificar puertos y procesos en Linux",
    "description": "Muchas veces necesitamos saber que puertos esta escuchando nuestro servidor para usar el cliente y conectar o bien para configurar nuestro firewall y así permitir las conexiones a dicho servicio o simplemente por información. Veremos como podemos consultar en nuestro sistema GNU/linux cuales puertos están siendo utilizados y que servicios o aplicaciones los están usando.",
    "author": [
      {
        "name": "José R Sosa",
        "url": "https://example.com/josersosa"
      }
    ],
    "date": "2012-09-20",
    "categories": [
      "Linux Recipes"
    ],
    "contents": "\n\nContents\nEl registro de servicios estándar: Archivo “services”\nListado de aplicaciones o servicios activos: “lsof”\nEstado y uso de la red en el equipo local: “netstat”\nEscaneo de puertos de equipos en la red: “nmap”\nIdentificando la aplicación que usa determinado puerto: “fuser”\nIdentificando los ID de procesos: “pidof”\nEjemplos de uso de estos comandos\nQue servicio usa el puerto 138 en el protocolo udp:\nQue puertos usa el servicio avahi-dae:\nQue versión uso en ssh:\nQue servicios tengo escuchando en mi Linux:\n\nAutomatizando estas tareas\nQue servicios uso, ejemplo: lss\nQue servicio usa un puerto dado, por ejemplo: lsw 22\nQue versión tiene mi servicio, por ejemplo: lsv ssh\n\n\nA continuación revisaremos las principales herramientas para identificar los puertos activos y las aplicaciones que los están utilizando. Para poder ejecutar estos comando es necesario tener privilegios de administrador (usuario root) o utilizar el comando sudo, anteponiéndolo a estos comandos.\nEl registro de servicios estándar: Archivo “services”\nPara saber que puertos esta escuchando nuestro servidor podemos consultar el archivo /etc/services en el cual se registran diferentes servicios, el puerto que usa y un pequeño comentario. Este archivo de configuración mantiene el registro de todos los puertos estándar. Por ejemplo, si queremos saber que puerto usa por defecto el servicio ssh haría:\ngrep -i ssh /etc/services\nLa salida del comando anterior sería:\nssh       22/tcp  #Secure Shell Login\nssh       22/udp  #Secure Shell Login\nsshell     614/tcp  #SSLshell\nsshell     614/udp\nx11-ssh     6010/tcp  #Unofficial name, for convenience\nx11-ssh     6010/udp\nListado de aplicaciones o servicios activos: “lsof”\nEl problema que muchas veces el servicio no viene registrado en el archivo services o viene pero no muestra todos los puertos que en realidad escucha. En estos caso podemos utilizar otros programas como lsof o “list open files”. Entre los datos que arroja como salida este programa esta el puerto utilizado, por lo que otras maneras de averiguar el puerto/s que usa nuestra aplicación es:\nlsof -n -i -P | grep '*:'\nPor ejemplo, si quiero saber que puestos escucha el samba haría:\nsudo lsof -n -i -P | grep '*:' | grep -e nmbd -e smbd\nEstado y uso de la red en el equipo local: “netstat”\nOtra manera de lograr nuestro objetivo es utilizando el comando netstat o “network statistics”, de la siguiente manera:\nnetstat -ltunp\nO si queremos el puerto de una aplicación especifica:\nnetstat -ltunp | grep -e smbd -e nmbd\nEscaneo de puertos de equipos en la red: “nmap”\nOtra manera de ver los puertos es usar un escaner que nos de la información del servicio como puede ser nmap. Nmap es un excelente escaner de puertos que nos da mucha información de los servicios/puertos que usa el PC.\nPara escanear con nmap, basta con:\nnmap $HOSTNAME\nLa salida del anterior comando sería por ejemplo:\nPORT STATE SERVICE\n22/tcp open ssh\n80/tcp open http\n139/tcp open netbios-ssn\n445/tcp open microsoft-ds\n901/tcp open samba-swat\n3333/tcp open dec-notes\n4000/tcp open remoteanything\n6667/tcp open irc\n6881/tcp open bittorent-tracker\nComo vemos en la salida, se nos presenta el puerto/protocolo estado servicio, por defecto nmap realiza un escaneo del tipo sT (TCP connect scan) a los puertos por defecto. Si queremos ver mas información de los servicios, versión así como escanear ambos protocolos (tcp y udp) y todos los puertos haríamos:\nnmap -sV -A -O -sT -sU -p - $HOSTNAME\nComo vemos, su salida sera mas extensa. El inconveniente es que nmap sabe el servicio que usa un puerto por el archivo services y muchas veces no viene dicho servicio saliendo algo así como unknown, por ello deberemos de hacer uso de los comandos lsof, netstat y nmap para averiguar información de los puertos, servicios y demás información.\nIdentificando la aplicación que usa determinado puerto: “fuser”\nSi queremos saber a la inversa, o sea, si se el puerto/protocolo y quiero saber que servicio lo esta usando podría usar fuser a parte de los anteriores:\nfuser -n <protocolo> -v <puerto>\nO de forma abreviada:\nfuser puerto/protocolo\nPor ejemplo, si quiero saber que servicio esta usando el puerto 3333/tcp haría:\nfuser -n tcp -v 3333\nEl anterior comando me diría lo siguiente:\nUSER PID ACCESS COMMAND\n3333/tcp: c 6987 F.... eggdrop\nIdentificando los ID de procesos: “pidof”\nEste comando no permite saber cual es el numero de PID del demonio una aplicación, en particular los servicios. Ejemplo para el servicio ssh:\npidof sshd\nEjemplos de uso de estos comandos\nComo resumen pongo algunos ejemplos:\nQue servicio usa el puerto 138 en el protocolo udp:\nfuser -n udp -v 138\nQue puertos usa el servicio avahi-dae:\nsudo lsof -ni -P | grep avahi-dae\nQue versión uso en ssh:\nnmap -sV -p ssh $HOSTNAME\nQue servicios tengo escuchando en mi Linux:\nlsof -ni | grep '*:' | awk '{ print $1 }' | sort -u\nAutomatizando estas tareas\nPara que sea mas fácil, podríamos crear las siguientes funciones y meterlas en el archivo .bashrc:\nvi ~/.bashrc\nQue servicios uso, ejemplo: lss\nfunction lss {\nsudo lsof -ni | grep \"*:\" | awk '{ print $1 }' | sort -u\n}\nQue puertos usa el servicio dado, por ejemplo: lsp amule\nfunction lsp {\nsudo lsof -ni -P | grep \"*:\" | grep $1 | awk '{ print $1,$7,$8 }' | sed -e \"s/*://g\" | sort\n}\nQue servicio usa un puerto dado, por ejemplo: lsw 22\nfunction lsw {\nsudo fuser -n tcp -v $1 || sudo fuser -n udp -v $1\n}\nCual es el numero de proceso de mi servicio, ejemplo: lspi eggdrop\nfunction lspi {\necho -e \"$1 `sudo pidof $1`\"\n}\nQue versión tiene mi servicio, por ejemplo: lsv ssh\nfunction lsv {\nV=`which nmap`\nif [ -z $V ]; then\necho -e \"No dispone del programa nmap\"\nelse\necho \"$1 -> \\\"`sudo nmap -sV -sT -sU -p $1 linux | grep $1 | awk '{print $3,$4,$5,$6,$7,$8,$9,$10}'`\\\"\"\nfi\n}\nUna vez añadida las funciones al .bashrc lo releemos para que se actualicé así:\nsource ~/.bashrc\nA partir de ahora ya podríamos usarlo\nFuente: http://chakal.homelinux.com/blog/?p=101\n\n\n\n",
    "preview": "posts/2021-05-08-como-verificar-puertos-y-procesos-en-linux/../../images/edex-ui.png",
    "last_modified": "2021-05-08T14:46:13+00:00",
    "input_file": {},
    "preview_width": 800,
    "preview_height": 450
  },
  {
    "path": "posts/2021-05-09-calculo-de-probabilidades-y-combinatorias-en-linea-de-comandos/",
    "title": "Cálculo de probabilidades y combinatorias por línea de comandos",
    "description": "Mediante la herramienta \"bc\" es posible contar con un poderosa calculadora desde la línea de comandos en Linux, con la que podemos realizar complejos cálculos de probabilidades. Esta Calculadora nos permite trabajar con precisión infinita en diversas bases, incluso podemos predefinir funciones para el calculo de combinatorias y funciones de probabilidad para las variables aleatorias con nombre propio, y esta es, precisamente, la razón de este post.",
    "author": [
      {
        "name": "José R Sosa",
        "url": "https://josersosa.github.io/personalweb/"
      }
    ],
    "date": "2011-08-30",
    "categories": [
      "Linux Recipes"
    ],
    "contents": "\n\nContents\nEl comando “bc”\nCálculo de combinatorias y probabilidades\nReferencias\n\nEl comando “bc”\nPara llamar a la aplicación bc escribimos desde la consola la siguiente instrucción:\n$ bc -il \nCon esta sentencia convocamos nuestra calculadora en modo interactivo (-i) y enlazando la librería matemática (-l)\nPara obtener la lista completa de parámetros de esta aplicación, la ejecutamos:\n$ bc --help\nusage: bc [options] [file ...]\n  -h  --help         print this usage and exit\n  -i  --interactive  force interactive mode\n  -l  --mathlib      use the predefined math routines\n  -q  --quiet        do not print initial banner\n  -s  --standard     non-standard bc constructs are errors\n  -w  --warn         warn about non-standard bc constructs\n  -v  --version      print version information and exit\nSi queremos incluir cálculos matemáticos dentro de un script de Linux es necesario pasar las formulas al comando bc, para eso podemos usar un pipeline, así:\n#!/bin/bash \necho 'scale=4; 10/3' | bc -l\nCálculo de combinatorias y probabilidades\nPara incorporar las funciones de cálculo de combinatorias debemos definir las correspondientes funciones en el ambiente de bc, también podemos pre-cargarlas a través de un archivo donde ya estén estas codificadas. Yo he preparado una versión de este archivo, que he llamado bc_defines.bc que pueden descargar de este enlace.\nAquí el contenido de este archivo:\npi = 4*a(1)\nnep = e(1)\ndefine fact (x) {\n  if (x <= 1) return (1);\n  return (fact(x-1) * x);\n  }\ndefine comb (n,x) {\n  return fact(n)/(fact(n-x)*fact(x))\n  }\ndefine poisson (s,x) {\n  return e(-s)*s^x/fact(x)\n  }\ndefine apoisson (s,x) { suma=0; for (i=0;i<=x;i++){ suma=suma+poisson(s,i)}; return suma}\n\ndefine binomial (n,p,x) {\n  return comb(n,x)*p^x*(1-p)^(n-x)\n  }\ndefine abinomial (n,p,x) { suma=0; for (i=0;i<=x;i++){ suma=suma+binomial(n,p,i)}; return suma}\n\ndefine geometrica (p,x) {\n  return p*(1-p)^x\n  }\ndefine ageometrica (p,x) { suma=0; for (i=0;i<=x;i++){ suma=suma+geometrica(p,i)}; return suma}\n\ndefine binomialneg (n,p,x) {\n  return comb(n+x-1,x)*p^n*(1-p)^x\n  }\ndefine abinomialneg (n,p,x) { suma=0; for (i=0;i<=x;i++){ suma=suma+binomialneg(n,p,i)}; return suma}\n\ndefine hipergeometrica (n,m,k,x) {\n  return comb(m,x)*comb(k,n-x)/comb(m+k,n)\n  }\ndefine ahipergeometrica (n,m,p,x) { suma=0; for (i=0;i<=x;i++){ suma=suma+hipergeometrica(n,m,p,i)}; return suma}\nPara ejecutar bc con las funciones que predefinimos escribimos:\n$ bc -il bc_defines.bc\nEn el, se implementan una serie de funciones que describo a continuación:\ncomb (n,x): Combinaciones de n en x.\npoisson (s,x): Función de probabilidad de la Poisson en x con parámetro s.\napoisson (s,x): Función de probabilidad acumulada de la Poisson en x con parámetro s.\nbinomial (n,p,x): Función de probabilidad de la Binomial en x con parámetros n y p.\nabinomial (n,p,x): Función de probabilidad acumulada de la Binomial en x con parámetros n y p.\ngeometrica (p,x): Función de probabilidad de la Geométrica en x con parámetro p.\nageometrica (p,x): Función de probabilidad acumulada de la Geométrica en x con parámetro p.\nbinomialneg (n,p,x): Función de probabilidad de la Binomial Negativa en x con parámetros n y p.\nabinomialneg (n,p,x): Función de probabilidad acumulada de la Binomial Negativa en x con parámetros n y p.\nhipergeometrica (n,m,k,x): Función de probabilidad de la Hipergeométrica en x con parámetros n, m y k.\nahipergeometrica (n,m,p,x): Función de probabilidad acumulada de la Hipergeométrica en x con parámetros n, m y k.\nReferencias\nCálculo numérico con bc\nCalculadora de línea de comandos\nEspero que les sirva…\n\n\n\n",
    "preview": "posts/2021-05-09-calculo-de-probabilidades-y-combinatorias-en-linea-de-comandos/../../images/tn_bc.jpg",
    "last_modified": "2021-05-10T02:05:43+00:00",
    "input_file": "calculo-de-probabilidades-y-combinatorias-en-linea-de-comandos.utf8.md"
  }
]
